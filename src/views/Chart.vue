<template>
	<div class="chart">
		<form name="chartForm">
			<openwb-base-card
				title="Filter"
				:collapsible="true"
				:collapsed="false"
			>
				<openwb-base-select-input
					title="Zeitraum"
					v-model="chartRange"
					:options="[
						{ value: 'day', text: 'Tag' },
						{ value: 'month', text: 'Monat' },
						{ value: 'year', text: 'Jahr' },
					]"
				/>
				<openwb-base-text-input
					:title="dateInput.title"
					:subtype="dateInput.type"
					:min="dateInput.min"
					:max="currentDate"
					:showQuickButtons="true"
					v-model="chartDate"
					@update:model-value="updateChart()"
				/>
			</openwb-base-card>
			<openwb-base-alert v-if="!chartDataRead" subtype="info">
				Es wurden noch keine Daten abgerufen.
			</openwb-base-alert>
			<div v-else>
				<openwb-base-alert v-if="!chartDataHasEntries" subtype="info">
					Es konnten keine Daten f체r diesen Zeitraum gefunden werden.
				</openwb-base-alert>
				<div v-else>
					<openwb-base-card
						title="Diagramm"
						:collapsible="true"
						:collapsed="false"
					>
						<div class="openwb-chart">
							<chartjs-line
								ref="myChart"
								:data="chartData"
								:options="chartOptions"
								@click="handleChartClick"
							/>
						</div>
					</openwb-base-card>
					<openwb-base-card
						title="Summen"
						:collapsible="true"
						:collapsed="true"
					>
						<div
							v-for="(group, groupKey) in chartTotals"
							:key="groupKey"
						>
							<openwb-base-card
								v-if="Object.keys(group).length > 0"
								:collapsible="true"
								:collapsed="true"
								:subtype="getCardSubtype(groupKey)"
							>
								<template #header>
									<font-awesome-icon
										fixed-width
										:icon="getCardIcon(groupKey)"
									/>
									{{ getTotalsLabel(groupKey) }}
								</template>
								<div
									v-for="(component, componentKey) in group"
									:key="componentKey"
								>
									<openwb-base-heading
										v-if="groupKey !== 'hc'"
										>{{
											getTotalsLabel(
												groupKey,
												componentKey,
											)
										}}</openwb-base-heading
									>
									<div
										v-for="(
											measurement, measurementKey
										) in component"
										:key="measurementKey"
									>
										<openwb-base-text-input
											:title="
												getTotalsLabel(
													groupKey,
													componentKey,
													measurementKey,
												)
											"
											readonly
											class="text-right"
											unit="kWh"
											:model-value="
												formatNumber(
													measurement / 1000,
													3,
												)
											"
										/>
									</div>
								</div>
							</openwb-base-card>
						</div>
					</openwb-base-card>
				</div>
			</div>
		</form>
	</div>
</template>

<script>
import { library } from "@fortawesome/fontawesome-svg-core";
import {
	faChargingStation as fasChargingStation,
	faCarBattery as fasCarBattery,
	faSolarPanel as fasSolarPanel,
	faGaugeHigh as fasGaugeHigh,
	faHouseSignal as fasHouseSignal,
	faHouse as fasHouse,
} from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";

library.add(
	fasChargingStation,
	fasCarBattery,
	fasSolarPanel,
	fasGaugeHigh,
	fasHouseSignal,
	fasHouse,
);

import ComponentState from "../components/mixins/ComponentState.vue";

import { Line as ChartjsLine, getElementAtEvent } from "vue-chartjs";
import "chartjs-adapter-luxon";
import "hammerjs";
import ZoomPlugin from "chartjs-plugin-zoom";
import {
	Chart,
	Tooltip,
	Legend,
	LineController,
	LineElement,
	BarController,
	BarElement,
	PointElement,
	LinearScale,
	TimeScale,
	Filler,
} from "chart.js";
Chart.register(
	Tooltip,
	Legend,
	LineController,
	LineElement,
	BarController,
	BarElement,
	PointElement,
	LinearScale,
	TimeScale,
	Filler,
	ZoomPlugin,
);

export default {
	name: "OpenwbChart",
	components: { ChartjsLine, FontAwesomeIcon },
	mixins: [ComponentState],
	emits: ["sendCommand"],
	props: {
		initialChartRange: {
			type: String,
			required: false,
			validator: function (value) {
				return ["day", "month", "year"].indexOf(value) !== -1;
			},
			default: "day",
		},
		initialDate: {
			type: String,
			required: false,
			validator: function (value) {
				return value.match(/^(([0-9]{4})(-[0-9]{2}(-[0-9]{2})?)?)?$/g);
			},
			default: "",
		},
	},
	data() {
		return {
			mqttTopicsToSubscribe: [
				"openWB/general/extern",
				"openWB/log/daily/#",
				"openWB/log/monthly/#",
				"openWB/log/yearly/#",
				"openWB/system/device/+/component/+/config",
				"openWB/chargepoint/+/config",
				"openWB/vehicle/+/name",
			],
			currentDate: "",
			chartRange: "day",
			blockChartInit: false,
			chartRequestDate: {
				day: "",
				month: "",
				year: "",
			},
			datasetTemplates: {
				"counter-power_average": {
					label: "Z채hler",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(255, 0, 0, 0.7)",
					backgroundColor: "rgba(255, 10, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"counter-energy_imported": {
					label: "Z채hler",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(255, 0, 0, 0.7)",
					backgroundColor: "rgba(255, 10, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"counter-energy_exported": {
					label: "Z채hler",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(0, 255, 105, 0.7)",
					backgroundColor: "rgba(0, 255, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"pv-power_exported": {
					label: "PV",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(40, 167, 69, 0.7)",
					backgroundColor: "rgba(10, 255, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					stack: "inverter-power",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"pv-energy_exported": {
					label: "PV",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(40, 167, 69, 0.7)",
					backgroundColor: "rgba(10, 255, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					stack: "inverter-exported",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"bat-power_average": {
					label: "Speicher",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(200, 255, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					stack: "battery-power",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"bat-energy_imported": {
					label: "Speicher",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(200, 255, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					stack: "battery-imported",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"bat-energy_exported": {
					label: "Speicher",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(200, 255, 13, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					stack: "battery-exported",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"bat-soc": {
					label: "Speicher SoC",
					unit: "%",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(200, 255, 13, 0.3)",
					borderDash: [10, 5],
					hidden: true,
					fill: false,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					borderWidth: 2,
					data: null,
					yAxisID: "y3",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"cp-power_average": {
					label: "Ladepunkt",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(0, 0, 255, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					stack: "charge-point-power",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"cp-energy_imported": {
					label: "Ladepunkt",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(0, 0, 255, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					stack: "charge-point-imported",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"cp-energy_imported_grid": {
					label: "Ladepunkt (Netzanteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(255, 0, 0, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "charge-point-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"cp-energy_imported_pv": {
					label: "Ladepunkt (PV-Anteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(40, 167, 69, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "charge-point-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"cp-energy_imported_bat": {
					label: "Ladepunkt (PV-Anteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "charge-point-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"ev-soc": {
					label: "Fahrzeug SoC",
					unit: "%",
					jsonKey: null,
					borderColor: "rgba(0, 0, 255, 0.7)",
					backgroundColor: "rgba(0, 0, 255, 0.3)",
					borderDash: [10, 5],
					hidden: true,
					fill: false,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					borderWidth: 2,
					data: null,
					yAxisID: "y3",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"sh-power_average": {
					label: "SmartHome",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(232, 62, 140, 0.7)",
					backgroundColor: "rgba(232, 72, 150, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"sh-energy_imported": {
					label: "SmartHome",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(232, 62, 140, 0.7)",
					backgroundColor: "rgba(232, 72, 150, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"sh-energy_exported": {
					label: "SmartHome",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(232, 62, 140, 0.7)",
					backgroundColor: "rgba(232, 72, 150, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: false,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"hc-power_imported": {
					label: "Hausverbrauch",
					unit: "kW",
					jsonKey: null,
					borderColor: "rgba(120, 122, 124, 0.7)",
					backgroundColor: "rgba(120, 122, 124, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"hc-energy_imported": {
					label: "Hausverbrauch",
					unit: "kWh",
					jsonKey: null,
					borderColor: "rgba(120, 122, 124, 0.7)",
					backgroundColor: "rgba(120, 122, 124, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 1,
					data: null,
					yAxisID: "y2",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"hc-energy_imported_grid": {
					label: "Hausverbrauch (Netzanteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(255, 0, 0, 0.7)",
					backgroundColor: "rgba(120, 122, 124, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "hc-energy-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"hc-energy_imported_pv": {
					label: "Hausverbrauch (PV-Anteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(40, 167, 69, 0.7)",
					backgroundColor: "rgba(120, 122, 124, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "hc-energy-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
				"hc-energy_imported_bat": {
					label: "Hausverbrauch (PV-Anteil)",
					unit: "kWh",
					type: "bar",
					jsonKey: null,
					borderColor: "rgba(253, 126, 20, 0.7)",
					backgroundColor: "rgba(120, 122, 124, 0.3)",
					fill: true,
					pointStyle: "circle",
					pointRadius: 0,
					pointHoverRadius: 4,
					cubicInterpolationMode: "monotone",
					hidden: true,
					borderWidth: 3,
					data: null,
					yAxisID: "y2",
					stack: "hc-energy-imported-source",
					parsing: {
						xAxisKey: "timestamp",
						yAxisKey: null,
					},
				},
			},
			chartOptions: {
				plugins: {
					title: {
						display: false,
					},
					tooltip: {
						enabled: true,
						callbacks: {
							label: (item) =>
								`${item.dataset.label}: ${item.formattedValue} ${item.dataset.unit}`,
						},
					},
					legend: {
						display: true,
					},
					zoom: {
						// Container for pan options
						pan: {
							// Boolean to enable panning
							enabled: true,
							// Panning directions. Remove the appropriate direction to disable
							// Eg. 'y' would only allow panning in the y direction
							mode: "x",
							threshold: 5,
						},
						// Container for zoom options
						zoom: {
							// Boolean to enable zooming
							wheel: {
								enabled: true,
							},
							pinch: {
								enabled: true,
							},
							// Zooming directions. Remove the appropriate direction to disable
							// Eg. 'y' would only allow zooming in the y direction
							mode: "x",
						},
					},
				},
				elements: {
					point: {
						radius: 2,
					},
				},
				responsive: true,
				maintainAspectRatio: false,
				interaction: {
					mode: "index",
					intersect: false,
				},
				scales: {
					x: {
						type: "time",
						time: {
							unit: "",
							tooltipFormat: "",
						},
						display: true,
						title: {
							display: true,
							text: "",
						},
						ticks: {
							source: "timestamp",
							font: {
								size: 12,
							},
							// color: tickColor,
							maxTicksLimit: 0,
						},
						grid: {
							// color: xGridColor,
						},
					},
					y: {
						// left side (power, kW)
						position: "left",
						type: "linear",
						display: "auto",
						suggestedMin: 0,
						suggestedMax: 0,
						title: {
							font: {
								size: 12,
							},
							display: true,
							text: "Leistung [kW]",
							// color: fontColor
						},
						grid: {
							// color: gridColor
						},
						ticks: {
							font: {
								size: 12,
							},
							stepSize: 0.2,
							maxTicksLimit: 11,
							// color: tickColor
						},
					},
					y2: {
						// left side (energy, kWh)
						position: "left",
						type: "linear",
						display: "auto",
						suggestedMin: 0,
						suggestedMax: 0,
						title: {
							font: {
								size: 12,
							},
							display: true,
							text: "Energie [kWh]",
							// color: fontColor
						},
						grid: {
							// color: gridColor
						},
						ticks: {
							font: {
								size: 12,
							},
							stepSize: 0.2,
							maxTicksLimit: 11,
							// color: tickColor
						},
					},
					y3: {
						// right side (SoC, %)
						position: "right",
						type: "linear",
						display: "auto",
						suggestedMin: 0,
						suggestedMax: 100,
						title: {
							font: {
								size: 12,
							},
							display: true,
							text: "SoC [%]",
							// color: fontColor
						},
						grid: {
							display: false,
							// color: gridSocColor,
						},
						ticks: {
							font: {
								size: 12,
							},
							stepSize: 10,
							maxTicksLimit: 11,
							// color: tickColor
						},
					},
				},
			},
			chartDatasets: {
				datasets: [],
			},
		};
	},
	computed: {
		dateInput() {
			var dateObject = {
				title: "Datum",
				type: "date",
				min: "2018-01-01",
			};
			switch (this.chartRange) {
				case "month":
					dateObject = {
						title: "Monat",
						type: "month",
						min: "2018-01",
					};
					break;
				case "year":
					dateObject = {
						title: "Jahr",
						type: "year",
						min: "2018",
					};
					break;
			}
			return dateObject;
		},
		chartDate: {
			get() {
				var dateString = this.chartRequestDate.year;
				if (this.chartRange != "year") {
					dateString = dateString + "-" + this.chartRequestDate.month;
				}
				if (this.chartRange == "day") {
					dateString = dateString + "-" + this.chartRequestDate.day;
				}
				return dateString;
			},
			set(newValue) {
				let splitDate = newValue.split("-");
				this.chartRequestDate.year = splitDate[0];
				if (splitDate.length > 1) {
					this.chartRequestDate.month = splitDate[1];
				} else {
					this.chartRequestDate.month = "";
				}
				if (splitDate.length > 2) {
					this.chartRequestDate.day = splitDate[2];
				} else {
					this.chartRequestDate.day = "";
				}
			},
		},
		chartScaleX() {
			var scaleObject = {
				unit: "minute",
				tooltipFormat: "DD T",
				text: "Zeit",
				maxTicksLimit: 24,
			};
			switch (this.chartRange) {
				case "month":
					scaleObject = {
						unit: "day",
						tooltipFormat: "DD",
						text: "Tag",
						maxTicksLimit: 31,
					};
					break;
				case "year":
					scaleObject = {
						unit: "month",
						tooltipFormat: "LLLL yyyy",
						text: "Monat",
						maxTicksLimit: 12,
					};
					break;
			}
			return scaleObject;
		},
		commandData() {
			var dataObject = {
				date:
					this.chartRequestDate.year +
					this.chartRequestDate.month +
					this.chartRequestDate.day,
				day:
					this.chartRequestDate.year +
					this.chartRequestDate.month +
					this.chartRequestDate.day,
			};
			switch (this.chartRange) {
				case "month":
					dataObject = {
						date:
							this.chartRequestDate.year +
							this.chartRequestDate.month,
						month:
							this.chartRequestDate.year +
							this.chartRequestDate.month,
					};
					break;
				case "year":
					dataObject = {
						date: this.chartRequestDate.year,
						year: this.chartRequestDate.year,
					};
					break;
			}
			return dataObject;
		},
		baseTopic() {
			var topic = "openWB/log/";
			switch (this.chartRange) {
				case "day":
					topic = topic + "daily/";
					break;
				case "month":
					topic = topic + "monthly/";
					break;
				case "year":
					topic = topic + "yearly/";
					break;
			}
			return topic;
		},
		chartDataRead() {
			return this.chartDataObject != undefined;
		},
		chartDataHasEntries() {
			if (this.chartDataObject) {
				return this.chartDataObject.length > 0;
			}
			return false;
		},
		chartTotals() {
			if (
				this.$store.state.mqtt[this.baseTopic + this.commandData.date]
			) {
				if (
					Object.prototype.hasOwnProperty.call(
						this.$store.state.mqtt[
							this.baseTopic + this.commandData.date
						],
						"totals",
					)
				) {
					var totals = JSON.parse(
						JSON.stringify(
							this.$store.state.mqtt[
								this.baseTopic + this.commandData.date
							].totals,
						),
					);
					// remove not relevant data for easier parsing
					delete totals.energy_source;
					Object.keys(totals.counter).forEach((component) => {
						if (
							Object.prototype.hasOwnProperty.call(
								totals.counter[component],
								"grid",
							)
						) {
							delete totals.counter[component].grid;
						}
					});
					return totals;
				}
			}
			return undefined;
		},
		chartDataObject() {
			if (
				this.$store.state.mqtt[this.baseTopic + this.commandData.date]
			) {
				var chartEntries =
					this.$store.state.mqtt[
						this.baseTopic + this.commandData.date
					];
				if (
					Object.prototype.hasOwnProperty.call(
						chartEntries,
						"entries",
					)
				) {
					chartEntries = chartEntries.entries;
				}
				var myData = JSON.parse(JSON.stringify(chartEntries)).map(
					(row) => {
						row.timestamp = row.timestamp * 1000;
						return row;
					},
				);
				return myData;
			}
			return undefined;
		},
		chartData() {
			if (this.chartDataObject) {
				// add all datasets available in the last entry
				var baseObjectsToProcess = [
					"pv",
					"counter",
					"bat",
					"cp",
					"sh",
					"ev",
					"hc",
				];
				const lastElement =
					this.chartDataObject[this.chartDataObject.length - 1];
				if (lastElement) {
					baseObjectsToProcess.forEach((baseObject) => {
						if (
							Object.prototype.hasOwnProperty.call(
								lastElement,
								baseObject,
							)
						) {
							Object.entries(lastElement[baseObject]).forEach(
								([key, value]) => {
									Object.keys(value).forEach((entryKey) => {
										this.initDataset(
											baseObject,
											key,
											entryKey,
										);
									});
								},
							);
						}
					});
				}
				return this.chartDatasets;
			}
			return undefined;
		},
	},
	methods: {
		handleChartClick(event) {
			if (this.chartRange == "day") {
				// no click actions for daily charts
				return;
			}
			const chart = this.$refs.myChart.chart;
			if (!chart) {
				return;
			}
			const element = getElementAtEvent(chart, event);
			if (!element.length) {
				return;
			}
			const { datasetIndex, index } = element[0];
			const clickedDate =
				this.chartData.datasets[datasetIndex].data[index].date;
			var newDate = "";
			var newRange = "";
			switch (this.chartRange) {
				case "month":
					newDate =
						clickedDate.substring(0, 4) +
						"-" +
						clickedDate.substring(4, 6) +
						"-" +
						clickedDate.substring(6);
					newRange = "day";
					break;
				case "year":
					newDate =
						clickedDate.substring(0, 4) +
						"-" +
						clickedDate.substring(4, 6);
					newRange = "month";
					break;
			}
			// prevent setting default date for new range
			this.blockChartInit = true;
			this.chartDate = newDate;
			this.chartRange = newRange;
		},
		getCardSubtype(elementKey) {
			switch (elementKey) {
				case "bat":
					return "warning";
				case "counter":
					return "danger";
				case "cp":
					return "primary";
				case "pv":
					return "success";
				case "sh":
					return "pink";
				default:
					return "secondary";
			}
		},
		getCardIcon(elementKey) {
			switch (elementKey) {
				case "bat":
					return ["fas", "car-battery"];
				case "counter":
					return ["fas", "gauge-high"];
				case "cp":
					return ["fas", "charging-station"];
				case "pv":
					return ["fas", "solar-panel"];
				case "sh":
					return ["fas", "house-signal"];
				case "hc":
					return ["fas", "house"];
				default:
					return undefined;
			}
		},
		getDatasetHidden(baseObject, objectKey) {
			// ToDo
			console.debug("getDatasetHidden", baseObject, objectKey);
			return false;
		},
		getTotalsLabel(
			groupKey,
			componentKey = undefined,
			measurementKey = undefined,
		) {
			var label = "*test*";
			if (!componentKey && !measurementKey) {
				switch (groupKey) {
					case "bat":
						return "Speicher";
					case "counter":
						return "Z채hler";
					case "pv":
						return "Wechselrichter";
					case "cp":
						return "Ladepunkte";
					case "sh":
						return "SmartHome-Ger채te";
					case "hc":
						return "Hausverbrauch";
					default:
						console.warn("unknown group key:", groupKey);
				}
				return "*" + groupKey + "*";
			}
			if (componentKey && !measurementKey) {
				if (componentKey == "all") {
					return "Summe";
				} else {
					if (
						Object.prototype.hasOwnProperty.call(
							this.$store.state.mqtt[
								this.baseTopic + this.commandData.date
							],
							"names",
						)
					) {
						return this.$store.state.mqtt[
							this.baseTopic + this.commandData.date
						].names[componentKey];
					}
				}
			}
			if (componentKey && measurementKey) {
				switch (groupKey) {
					case "bat":
					case "cp":
						switch (measurementKey) {
							case "imported":
							case "energy_imported":
								return "Ladung";
							case "exported":
							case "energy_exported":
								return "Entladung";
							case "energy_imported_grid":
								return "Ladung (Netz-Anteil)";
							case "energy_imported_pv":
								return "Ladung (PV-Anteil)";
							case "energy_imported_bat":
								return "Ladung (Speicher-Anteil)";
							case "energy_imported_cp":
								return "Ladung (Ladepunkt-Anteil)";
							default:
								console.warn(
									"unknown measurement key:",
									groupKey,
									measurementKey,
								);
						}
						break;
					case "counter":
						switch (measurementKey) {
							case "imported":
							case "energy_imported":
								return "Bezug/Verbrauch";
							case "exported":
							case "energy_exported":
								return "Einspeisung/Erzeugung";
							default:
								console.warn(
									"unknown measurement key:",
									groupKey,
									measurementKey,
								);
						}
						break;
					case "pv":
						switch (measurementKey) {
							case "exported":
							case "energy_exported":
								return "Erzeugung";
							default:
								console.warn(
									"unknown measurement key:",
									groupKey,
									measurementKey,
								);
						}
						break;
					case "sh":
						switch (measurementKey) {
							case "imported":
							case "energy_imported":
								return "Verbrauch";
							case "exported":
							case "energy_exported":
								return "Erzeugung";
							default:
								console.warn(
									"unknown measurement key:",
									groupKey,
									measurementKey,
								);
						}
						break;
					case "hc":
						switch (measurementKey) {
							case "imported":
							case "energy_imported":
								return "Verbrauch";
							case "energy_imported_grid":
								return "Verbrauch (Netz-Anteil)";
							case "energy_imported_pv":
								return "Verbrauch (PV-Anteil)";
							case "energy_imported_bat":
								return "Verbrauch (Speicher-Anteil)";
							case "energy_imported_cp":
								return "Verbrauch (Ladepunkt-Anteil)";
							default:
								console.warn(
									"unknown measurement key:",
									groupKey,
									measurementKey,
								);
						}
						break;
					default:
						console.warn("unknown group key:", groupKey);
				}
				return (
					"*" +
					groupKey +
					"+" +
					componentKey +
					"+" +
					measurementKey +
					"*"
				);
			}
			return label;
		},
		/**
		 * Builds a label string
		 * @param {String} baseObject
		 * @param {String} objectKey
		 * @param {String} elementKey
		 * @param {String} datasetKey
		 * @returns {String}
		 */
		getDatasetLabel(baseObject, objectKey, elementKey, datasetKey) {
			var label = ["*" + datasetKey];
			var details = [];
			if (objectKey == "all") {
				if (baseObject !== "hc") {
					details.push("Summe");
				}
				switch (baseObject) {
					case "pv":
						label = ["PV"];
						break;
					case "bat":
						label = ["Speicher"];
						switch (elementKey) {
							case "soc":
								label.push("SoC");
								break;
						}
						break;
					case "cp":
						label = ["Ladepunkte"];
						break;
					case "hc":
						label = ["Hausverbrauch"];
				}
			} else {
				if (
					Object.prototype.hasOwnProperty.call(
						this.$store.state.mqtt[
							this.baseTopic + this.commandData.date
						],
						"names",
					) &&
					Object.prototype.hasOwnProperty.call(
						this.$store.state.mqtt[
							this.baseTopic + this.commandData.date
						].names,
						objectKey,
					)
				) {
					label = [
						this.$store.state.mqtt[
							this.baseTopic + this.commandData.date
						].names[objectKey],
					];
				}
			}
			switch (baseObject) {
				case "bat":
				case "ev":
				case "cp":
					switch (elementKey) {
						case "soc":
							details.push("SoC");
							break;
						case "energy_imported":
							details.push("Ladung");
							break;
						case "energy_exported":
							details.push("Entladung");
							break;
						case "energy_imported_grid":
							details.push("Netz-Anteil");
							break;
						case "energy_imported_pv":
							details.push("PV-Anteil");
							break;
						case "energy_imported_bat":
							details.push("Speicher-Anteil");
							break;
						case "energy_imported_cp":
							details.push("Ladepunkt-Anteil");
							break;
					}
					break;
				case "counter":
					switch (elementKey) {
						case "energy_imported":
							details.push("Bezug/Verbrauch");
							break;
						case "energy_exported":
							details.push("Einspeisung/Erzeugung");
							break;
					}
					break;
				case "sh":
					switch (elementKey) {
						case "energy_imported":
							details.push("Verbrauch");
							break;
						case "energy_exported":
							details.push("Erzeugung");
							break;
					}
					break;
				case "hc":
					switch (elementKey) {
						case "energy_imported_grid":
							details.push("Netz-Anteil");
							break;
						case "energy_imported_pv":
							details.push("PV-Anteil");
							break;
						case "energy_imported_bat":
							details.push("Speicher-Anteil");
							break;
						case "energy_imported_cp":
							details.push("Ladepunkt-Anteil");
							break;
					}
					break;
			}
			return `${label.join(" ")}${
				details.length ? " (" + details.join(", ") + ")" : ""
			}`;
		},
		getDatasetIndex(datasetKey) {
			let index = this.chartDatasets.datasets.findIndex((dataset) => {
				return dataset.jsonKey == datasetKey;
			});
			if (index != -1) {
				return index;
			}
			return;
		},
		addDataset(baseObject, objectKey, elementKey, datasetKey) {
			var datasetTemplate = baseObject + "-" + elementKey;
			if (this.datasetTemplates[datasetTemplate]) {
				var newDataset = JSON.parse(
					JSON.stringify(this.datasetTemplates[datasetTemplate]),
				);
				newDataset.parsing.yAxisKey = datasetKey;
				newDataset.jsonKey = datasetKey;
				newDataset.data = this.chartDataObject;
				// build dataset label
				newDataset.label = this.getDatasetLabel(
					baseObject,
					objectKey,
					elementKey,
					datasetKey,
				);
				if (newDataset.labelSuffix != undefined) {
					newDataset.label =
						newDataset.label + newDataset.labelSuffix;
				}
				if (objectKey == "all") {
					if (
						!["grid", "pv", "bat", "cp"].includes(
							elementKey.split("_").slice(-1)[0],
						)
					) {
						// only display general totals on load
						newDataset.hidden = false;
						// do not stack general totals
						delete newDataset.stack;
					}
				}
				return this.chartDatasets.datasets.push(newDataset) - 1;
			} else {
				console.warn(
					"no matching template found for: " +
						datasetKey +
						" with template: " +
						datasetTemplate,
				);
			}
			return;
		},
		initDataset(baseObject, objectKey, elementKey) {
			var elementKeysToAdd = [];
			if (this.chartRange == "day") {
				elementKeysToAdd = {
					counter: ["power_average"],
					pv: ["power_exported"],
					bat: ["power_average", "soc"],
					cp: ["power_average"],
					sh: ["power_average"],
					ev: ["soc"],
					hc: ["power_imported"],
				};
			} else {
				elementKeysToAdd = {
					counter: ["energy_imported", "energy_exported"],
					pv: ["energy_exported"],
					bat: ["energy_imported", "energy_exported"],
					cp: [
						"energy_imported",
						"energy_imported_grid",
						"energy_imported_pv",
						"energy_imported_bat",
					],
					sh: ["energy_imported", "energy_exported"],
					ev: [],
					hc: [
						"energy_imported",
						"energy_imported_grid",
						"energy_imported_pv",
						"energy_imported_bat",
					],
				};
			}
			const datasetKey = baseObject + "." + objectKey + "." + elementKey;
			if (elementKeysToAdd[baseObject].includes(elementKey)) {
				var index = this.getDatasetIndex(datasetKey);
				const hidden = this.getDatasetHidden(baseObject, objectKey);
				if (index == undefined && !hidden) {
					index = this.addDataset(
						baseObject,
						objectKey,
						elementKey,
						datasetKey,
					);
				}
				if (index != undefined && hidden) {
					// dataset is hidden
					this.chartDatasets.datasets.splice(index, 1);
				}
			} else {
				console.debug("skipping dataset:", datasetKey);
			}
		},
		setupScaleX() {
			this.chartOptions.scales.x.time.unit = this.chartScaleX.unit;
			this.chartOptions.scales.x.time.tooltipFormat =
				this.chartScaleX.tooltipFormat;
			this.chartOptions.scales.x.title.text = this.chartScaleX.text;
			this.chartOptions.scales.x.ticks.maxTicksLimit =
				this.chartScaleX.maxTicksLimit;
		},
		requestChart() {
			let myForm = document.forms["chartForm"];
			if (!myForm.reportValidity()) {
				console.warn("form invalid");
				return;
			} else {
				this.setupScaleX();
				this.chartDatasets.datasets = [];
				var command = "";
				switch (this.chartRange) {
					case "day":
						command = "getDailyLog";
						break;
					case "month":
						command = "getMonthlyLog";
						break;
					case "year":
						command = "getYearlyLog";
						break;
				}
				this.$emit("sendCommand", {
					command: command,
					data: this.commandData,
				});
			}
		},
		clearChartData() {
			this.getWildcardIndexList(this.baseTopic + "+").forEach((topic) => {
				this.$store.commit("removeTopic", `${this.baseTopic}${topic}`);
			});
		},
		updateChart() {
			this.clearChartData();
			this.requestChart();
		},
		init() {
			const today = new Date();
			this.currentDate = String(today.getFullYear());
			if (this.chartRange != "year") {
				this.currentDate =
					this.currentDate +
					"-" +
					String(today.getMonth() + 1).padStart(2, "0");
			}
			if (this.chartRange == "day") {
				this.currentDate =
					this.currentDate +
					"-" +
					String(today.getDate()).padStart(2, "0");
			}
			if (!this.blockChartInit) {
				if (this.initialDate == undefined || this.initialDate == "") {
					this.chartDate = this.currentDate;
				} else {
					this.chartDate = this.initialDate;
				}
			} else {
				this.blockChartInit = false;
			}
			this.updateChart();
		},
	},
	watch: {
		chartRange() {
			this.init();
		},
	},
	mounted() {
		this.init();
	},
};
</script>

<style scoped>
.openwb-chart {
	min-height: 400px;
}
</style>
